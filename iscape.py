# AUTOGENERATED! DO NOT EDIT! File to edit: iscape.ipynb.

# %% auto 0
__all__ = ['svc', 'scaler_fCC', 'scaler_ECFP', 'normalizer', 'featurizer', 'smiles_input', 'label_output', 'examples', 'intf',
           'calculate_properties', 'make_pred']

# %% iscape.ipynb 1
import numpy as np
import deepchem as dc
import gradio as gr
import joblib
from rdkit import Chem

# Function to calculate properties
def calculate_properties(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    
    # calculate the fraction of C-C pairs
    num_bonds = mol.GetNumBonds()
    num_cc_pairs = sum(1 for bond in mol.GetBonds() if bond.GetBeginAtom().GetSymbol() == 'C' and bond.GetEndAtom().GetSymbol() == 'C')
    frac_CC = num_cc_pairs / num_bonds if num_bonds > 0 else 0
    
    return frac_CC

# Load the pre-trained model
svc = joblib.load('svc.pkl')
scaler_fCC = joblib.load('scaler_qc.pkl')
scaler_ECFP = joblib.load('scaler_ecfp.pkl')
normalizer = joblib.load('normalizer.pkl')

# Circular fingerprint featurizer
featurizer = dc.feat.CircularFingerprint(radius=7, size=512, chiral=True, bonds=True,
                                        features=True, is_counts_based=True)

# Function to make predictions
def make_pred(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return "Invalid SMILES string"
    
    # Calculate frac_CC
    frac_CC = calculate_properties(smiles)
    if frac_CC is None:
        return "Error in property calculation"

    # Featurize SMILES using ECFP
    ecfp_features = featurizer.featurize([smiles])[0]

    # Scale the properties and ECFP features using pre-fitted scaler
    fCC_scaled = scaler_fCC.transform([[frac_CC]]) 
    ecfp_scaled = scaler_ECFP.transform([ecfp_features])
    
    # Combine properties and ECFP features
    X = np.concatenate([fCC_scaled, ecfp_scaled], axis=1)
    
    # Normalize the features using the pre-fitted normalizer
    X_norm = normalizer.transform(X)

    # Predict with the model
    pred = svc.predict(X_norm)
    
    # Return the prediction
    if pred[0] == 1:
        return "Active"
    else:
        return "Inactive"

# Define Gradio interface
smiles_input = gr.components.Textbox(label="Enter the SMILES of the peptide")
label_output = gr.components.Textbox(label="Antibacterial activity against E. coli")

# Example SMILES strings
examples = [['[NH2+]=C(N)NCCC[C@H](NC(=O)CCCCCCCCCCCCC)C(=O)N[C@@H](Cc1cnc[NH]1)C(N)=O'],
            ['NC(=O)[C@H](Cc1cnc[NH]1)NC(=O)[C@@H](NC(=O)CCCCCCCCCCCCC)Cc1cnc[NH]1']]

# Set up the Gradio interface
intf = gr.Interface(fn=make_pred, inputs=smiles_input, outputs=label_output, examples=examples)
intf.launch(inline=False)  
